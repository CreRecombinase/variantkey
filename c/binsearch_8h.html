<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>VariantKey: binsearch.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VariantKey
   &#160;<span id="projectnumber">5.4.1</span>
   </div>
   <div id="projectbrief">Numerical Encoding for Human Genetic Variants</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('binsearch_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">binsearch.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions to search values in binary files made of constant-length items.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;sys/mman.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
</div>
<p><a href="binsearch_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmmfile__t.html">mmfile_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3ffaace8b8aba6cc164abbcd02108daf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a3ffaace8b8aba6cc164abbcd02108daf">order_be_uint8_t</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:a3ffaace8b8aba6cc164abbcd02108daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;  <a href="#a3ffaace8b8aba6cc164abbcd02108daf">More...</a><br /></td></tr>
<tr class="separator:a3ffaace8b8aba6cc164abbcd02108daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f865e71b74172e5f252512e04a67c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a52f865e71b74172e5f252512e04a67c8">order_le_uint8_t</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:a52f865e71b74172e5f252512e04a67c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return LE uint8_t.  <a href="#a52f865e71b74172e5f252512e04a67c8">More...</a><br /></td></tr>
<tr class="separator:a52f865e71b74172e5f252512e04a67c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce4fd0dab9e96707e24efb31c2dc85f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#abce4fd0dab9e96707e24efb31c2dc85f">order_be_uint16_t</a>(x)&#160;&#160;&#160;(bswap_16(x))</td></tr>
<tr class="memdesc:abce4fd0dab9e96707e24efb31c2dc85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return BE uint16_t in the correct endianness order.  <a href="#abce4fd0dab9e96707e24efb31c2dc85f">More...</a><br /></td></tr>
<tr class="separator:abce4fd0dab9e96707e24efb31c2dc85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45175a282efa75e0bcaedaab16901ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae45175a282efa75e0bcaedaab16901ed">order_be_uint32_t</a>(x)&#160;&#160;&#160;(bswap_32(x))</td></tr>
<tr class="memdesc:ae45175a282efa75e0bcaedaab16901ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return BE uint32_t in the correct endianness order.  <a href="#ae45175a282efa75e0bcaedaab16901ed">More...</a><br /></td></tr>
<tr class="separator:ae45175a282efa75e0bcaedaab16901ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2142afb598f7581859021b5006d8ef0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ac2142afb598f7581859021b5006d8ef0">order_be_uint64_t</a>(x)&#160;&#160;&#160;(bswap_64(x))</td></tr>
<tr class="memdesc:ac2142afb598f7581859021b5006d8ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return BE uint64_t in the correct endianness order.  <a href="#ac2142afb598f7581859021b5006d8ef0">More...</a><br /></td></tr>
<tr class="separator:ac2142afb598f7581859021b5006d8ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af522ff60f5c32f6f45f3f3c4480fc60f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#af522ff60f5c32f6f45f3f3c4480fc60f">order_le_uint16_t</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:af522ff60f5c32f6f45f3f3c4480fc60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return LE uint16_t in the correct endianness order.  <a href="#af522ff60f5c32f6f45f3f3c4480fc60f">More...</a><br /></td></tr>
<tr class="separator:af522ff60f5c32f6f45f3f3c4480fc60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389753ec47839aa25004f497aa345af4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a389753ec47839aa25004f497aa345af4">order_le_uint32_t</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:a389753ec47839aa25004f497aa345af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return LE uint32_t in the correct endianness order.  <a href="#a389753ec47839aa25004f497aa345af4">More...</a><br /></td></tr>
<tr class="separator:a389753ec47839aa25004f497aa345af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d23a5e7b0dccb18a7b7f95968791b7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a5d23a5e7b0dccb18a7b7f95968791b7b">order_le_uint64_t</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:a5d23a5e7b0dccb18a7b7f95968791b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return LE uint64_t in the correct endianness order.  <a href="#a5d23a5e7b0dccb18a7b7f95968791b7b">More...</a><br /></td></tr>
<tr class="separator:a5d23a5e7b0dccb18a7b7f95968791b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a83dc415ae5e205183f0488b46228c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a6a83dc415ae5e205183f0488b46228c4">MAXCOLS</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:a6a83dc415ae5e205183f0488b46228c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of columns indexable.  <a href="#a6a83dc415ae5e205183f0488b46228c4">More...</a><br /></td></tr>
<tr class="separator:a6a83dc415ae5e205183f0488b46228c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c97ce65cada1ea153d17cd4bc61945b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a2c97ce65cada1ea153d17cd4bc61945b">get_address</a>(blklen,  blkpos,  item)&#160;&#160;&#160;(((blklen) * (item)) + (blkpos))</td></tr>
<tr class="separator:a2c97ce65cada1ea153d17cd4bc61945b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa58740ee6cbd77b5c7b6abd937226e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#acfa58740ee6cbd77b5c7b6abd937226e">get_middle_point</a>(first,  last)&#160;&#160;&#160;((first) + (((last) - (first)) &gt;&gt; 1))</td></tr>
<tr class="separator:acfa58740ee6cbd77b5c7b6abd937226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4eb5c24939d2b9ff2f1709972d15e70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#af4eb5c24939d2b9ff2f1709972d15e70">get_src_offset</a>(T,  src,  offset)&#160;&#160;&#160;((const T *)((src) + (offset)))</td></tr>
<tr class="separator:af4eb5c24939d2b9ff2f1709972d15e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1055e111581a0445a20f87dbcd51cd1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a1055e111581a0445a20f87dbcd51cd1a">define_bytes_to</a>(O,  T)</td></tr>
<tr class="separator:a1055e111581a0445a20f87dbcd51cd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6664e238bce881a60395ed2688158228"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a6664e238bce881a60395ed2688158228">define_get_src_offset</a>(T)</td></tr>
<tr class="separator:a6664e238bce881a60395ed2688158228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8b38d5244744dc6543471183eea68c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a1a8b38d5244744dc6543471183eea68c">GET_MIDDLE_BLOCK</a>(O,  T)&#160;&#160;&#160;order_##O##_##T(*(<a class="el" href="binsearch_8h.html#af4eb5c24939d2b9ff2f1709972d15e70">get_src_offset</a>(T, src, <a class="el" href="binsearch_8h.html#a2c97ce65cada1ea153d17cd4bc61945b">get_address</a>(blklen, blkpos, middle))))</td></tr>
<tr class="separator:a1a8b38d5244744dc6543471183eea68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517f9a371a5746519af013bcfd98774a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a>(T)</td></tr>
<tr class="separator:a517f9a371a5746519af013bcfd98774a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae844483cc5997bf2c85e55156fe9337e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a></td></tr>
<tr class="separator:ae844483cc5997bf2c85e55156fe9337e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fddeeba1901267a55ab890fa5e0d38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a>(T)</td></tr>
<tr class="separator:ad0fddeeba1901267a55ab890fa5e0d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f14b70467af041f6e5777506e4d63a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">GET_ITEM_TASK</a>(O,  T)&#160;&#160;&#160;x = <a class="el" href="binsearch_8h.html#a1a8b38d5244744dc6543471183eea68c">GET_MIDDLE_BLOCK</a>(O, T);</td></tr>
<tr class="separator:a1f14b70467af041f6e5777506e4d63a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de13eea7a6eb0fe4dd1c472b1e4b10c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a9de13eea7a6eb0fe4dd1c472b1e4b10c">COL_GET_ITEM_TASK</a>&#160;&#160;&#160;x = *(src + middle);</td></tr>
<tr class="separator:a9de13eea7a6eb0fe4dd1c472b1e4b10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b65a18c12c4857a2b059b1aa819675"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">GET_SUB_ITEM_TASK</a>(O,  T)&#160;&#160;&#160;x = ((<a class="el" href="binsearch_8h.html#a1a8b38d5244744dc6543471183eea68c">GET_MIDDLE_BLOCK</a>(O, T) &gt;&gt; rshift) &amp; bitmask);</td></tr>
<tr class="separator:a31b65a18c12c4857a2b059b1aa819675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fe1703a12ac2f98058173d69547fca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a01fe1703a12ac2f98058173d69547fca">COL_GET_SUB_ITEM_TASK</a>&#160;&#160;&#160;x = ((*(src + middle) &gt;&gt; rshift) &amp; bitmask);</td></tr>
<tr class="separator:a01fe1703a12ac2f98058173d69547fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a49b63792e4d038a3205402c18427c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a1a49b63792e4d038a3205402c18427c1">FIND_FIRST_INNER_CHECK</a></td></tr>
<tr class="separator:a1a49b63792e4d038a3205402c18427c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72baf12ebb2593d9f0961b0e11184996"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a72baf12ebb2593d9f0961b0e11184996">FIND_LAST_INNER_CHECK</a></td></tr>
<tr class="separator:a72baf12ebb2593d9f0961b0e11184996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43375f749044ed34cbac15d8a9ad351"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aa43375f749044ed34cbac15d8a9ad351">HAS_NEXT_START_BLOCK</a></td></tr>
<tr class="separator:aa43375f749044ed34cbac15d8a9ad351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ed7fb62474d143e8046028d4a73ee9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a20ed7fb62474d143e8046028d4a73ee9">HAS_PREV_START_BLOCK</a></td></tr>
<tr class="separator:a20ed7fb62474d143e8046028d4a73ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641b20c4420de81ffd7a891bd3d6e949"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a641b20c4420de81ffd7a891bd3d6e949">GET_POS_BLOCK</a>(O,  T)&#160;&#160;&#160;order_##O##_##T(*(<a class="el" href="binsearch_8h.html#af4eb5c24939d2b9ff2f1709972d15e70">get_src_offset</a>(T, src, <a class="el" href="binsearch_8h.html#a2c97ce65cada1ea153d17cd4bc61945b">get_address</a>(blklen, blkpos, *pos))))</td></tr>
<tr class="separator:a641b20c4420de81ffd7a891bd3d6e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117e255e20440263d826a32e6c05321e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a117e255e20440263d826a32e6c05321e">HAS_END_BLOCK</a>(O,  T)&#160;&#160;&#160;return (<a class="el" href="binsearch_8h.html#a641b20c4420de81ffd7a891bd3d6e949">GET_POS_BLOCK</a>(O, T) == search);</td></tr>
<tr class="separator:a117e255e20440263d826a32e6c05321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54897c0419aa9258693d79c7c916d18a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a54897c0419aa9258693d79c7c916d18a">COL_HAS_END_BLOCK</a>(T)&#160;&#160;&#160;return (*(src + *pos) == search);</td></tr>
<tr class="separator:a54897c0419aa9258693d79c7c916d18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9a64a545a1575318d354f8324b0341"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#afa9a64a545a1575318d354f8324b0341">HAS_SUB_END_BLOCK</a>(O,  T)&#160;&#160;&#160;return (((<a class="el" href="binsearch_8h.html#a641b20c4420de81ffd7a891bd3d6e949">GET_POS_BLOCK</a>(O, T) &gt;&gt; rshift) &amp; bitmask) == search);</td></tr>
<tr class="separator:afa9a64a545a1575318d354f8324b0341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921470c122edc1edf78f0d4687b9ae93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a921470c122edc1edf78f0d4687b9ae93">COL_HAS_SUB_END_BLOCK</a>(T)&#160;&#160;&#160;return (((*(src + *pos) &gt;&gt; rshift) &amp; bitmask) == search);</td></tr>
<tr class="separator:a921470c122edc1edf78f0d4687b9ae93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc7a72ed8e1d15f4cd07ece93031a90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a5bc7a72ed8e1d15f4cd07ece93031a90">define_find_first</a>(O,  T)</td></tr>
<tr class="separator:a5bc7a72ed8e1d15f4cd07ece93031a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1ea2763f11924b67b80cbd6bfee3ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ace1ea2763f11924b67b80cbd6bfee3ee">define_find_first_sub</a>(O,  T)</td></tr>
<tr class="separator:ace1ea2763f11924b67b80cbd6bfee3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa11401effbe93bd348d8c947027991"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a6aa11401effbe93bd348d8c947027991">define_find_last</a>(O,  T)</td></tr>
<tr class="separator:a6aa11401effbe93bd348d8c947027991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1e8903559637ba785c109e36422ae6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aee1e8903559637ba785c109e36422ae6">define_find_last_sub</a>(O,  T)</td></tr>
<tr class="separator:aee1e8903559637ba785c109e36422ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e99e4a289b381504aaee46fdb173841"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a9e99e4a289b381504aaee46fdb173841">define_has_next</a>(O,  T)</td></tr>
<tr class="separator:a9e99e4a289b381504aaee46fdb173841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42db86bef619b154edfc394d83bac0e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a42db86bef619b154edfc394d83bac0e7">define_has_next_sub</a>(O,  T)</td></tr>
<tr class="separator:a42db86bef619b154edfc394d83bac0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1486e08119eaa1295b3afbd3e970c6b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a1486e08119eaa1295b3afbd3e970c6b3">define_has_prev</a>(O,  T)</td></tr>
<tr class="separator:a1486e08119eaa1295b3afbd3e970c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4ea3b1de6b014d7e32c7d297d28a4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a3c4ea3b1de6b014d7e32c7d297d28a4e">define_has_prev_sub</a>(O,  T)</td></tr>
<tr class="separator:a3c4ea3b1de6b014d7e32c7d297d28a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a73e66f47ba95b6a693234b8e556c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae4a73e66f47ba95b6a693234b8e556c4">define_col_find_first</a>(T)</td></tr>
<tr class="separator:ae4a73e66f47ba95b6a693234b8e556c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3f7caaf555546c8258ab111304f504"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a7f3f7caaf555546c8258ab111304f504">define_col_find_first_sub</a>(T)</td></tr>
<tr class="separator:a7f3f7caaf555546c8258ab111304f504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4181ee1218ce7b4c942af44a0727c56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#af4181ee1218ce7b4c942af44a0727c56">define_col_find_last</a>(T)</td></tr>
<tr class="separator:af4181ee1218ce7b4c942af44a0727c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3494bf01e1976617617fe8f37a48cb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae3494bf01e1976617617fe8f37a48cb2">define_col_find_last_sub</a>(T)</td></tr>
<tr class="separator:ae3494bf01e1976617617fe8f37a48cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab894f514c256050cef02cb4251ec476e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ab894f514c256050cef02cb4251ec476e">define_col_has_next</a>(T)</td></tr>
<tr class="separator:ab894f514c256050cef02cb4251ec476e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb283d99efb97a73394876f9a9b4b60f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#adb283d99efb97a73394876f9a9b4b60f">define_col_has_next_sub</a>(T)</td></tr>
<tr class="separator:adb283d99efb97a73394876f9a9b4b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8919f8db2e76a1215fb94d2f35543d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ab8919f8db2e76a1215fb94d2f35543d5">define_col_has_prev</a>(T)</td></tr>
<tr class="separator:ab8919f8db2e76a1215fb94d2f35543d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad3ee7b0a6df6401b85f3241b03e0b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a6ad3ee7b0a6df6401b85f3241b03e0b6">define_col_has_prev_sub</a>(T)</td></tr>
<tr class="separator:a6ad3ee7b0a6df6401b85f3241b03e0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab7225c40735b7e72695c2dcd522601d9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmmfile__t.html">mmfile_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ab7225c40735b7e72695c2dcd522601d9">mmfile_t</a></td></tr>
<tr class="separator:ab7225c40735b7e72695c2dcd522601d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ba84555aa4d82113999e8a861348068"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a6ba84555aa4d82113999e8a861348068">bytes_be_to_uint8_t</a> (const uint8_t *src, uint64_t i)</td></tr>
<tr class="separator:a6ba84555aa4d82113999e8a861348068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a62801cb588f747292d4dddbc99b240"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a0a62801cb588f747292d4dddbc99b240">bytes_be_to_uint16_t</a> (const uint8_t *src, uint64_t i)</td></tr>
<tr class="separator:a0a62801cb588f747292d4dddbc99b240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a2b647ad635b560261ff697a2dfe35"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ac1a2b647ad635b560261ff697a2dfe35">bytes_be_to_uint32_t</a> (const uint8_t *src, uint64_t i)</td></tr>
<tr class="separator:ac1a2b647ad635b560261ff697a2dfe35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44265545f56907db0e66a59650d13525"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a44265545f56907db0e66a59650d13525">bytes_be_to_uint64_t</a> (const uint8_t *src, uint64_t i)</td></tr>
<tr class="separator:a44265545f56907db0e66a59650d13525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17292f2e6088f00fb6df4afc8bbd6be"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae17292f2e6088f00fb6df4afc8bbd6be">bytes_le_to_uint8_t</a> (const uint8_t *src, uint64_t i)</td></tr>
<tr class="separator:ae17292f2e6088f00fb6df4afc8bbd6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a18b3358cca8c7924a50a18aa802ce"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a89a18b3358cca8c7924a50a18aa802ce">bytes_le_to_uint16_t</a> (const uint8_t *src, uint64_t i)</td></tr>
<tr class="separator:a89a18b3358cca8c7924a50a18aa802ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6fc8c7fd52cffa0afbebe3913fdb47"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a2e6fc8c7fd52cffa0afbebe3913fdb47">bytes_le_to_uint32_t</a> (const uint8_t *src, uint64_t i)</td></tr>
<tr class="separator:a2e6fc8c7fd52cffa0afbebe3913fdb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80b5065ce2833b1a99cb81645623ba7"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ab80b5065ce2833b1a99cb81645623ba7">bytes_le_to_uint64_t</a> (const uint8_t *src, uint64_t i)</td></tr>
<tr class="separator:ab80b5065ce2833b1a99cb81645623ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95e4f6be694f7cddec74cbe67364332"><td class="memItemLeft" align="right" valign="top">static const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aa95e4f6be694f7cddec74cbe67364332">get_src_offset_uint8_t</a> (const uint8_t *src, uint64_t offset)</td></tr>
<tr class="separator:aa95e4f6be694f7cddec74cbe67364332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e221ab4a623997b0e4b3e87ff7adf6"><td class="memItemLeft" align="right" valign="top">static const uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a77e221ab4a623997b0e4b3e87ff7adf6">get_src_offset_uint16_t</a> (const uint8_t *src, uint64_t offset)</td></tr>
<tr class="separator:a77e221ab4a623997b0e4b3e87ff7adf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13845930a1d624c5cb26c56a0f480317"><td class="memItemLeft" align="right" valign="top">static const uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a13845930a1d624c5cb26c56a0f480317">get_src_offset_uint32_t</a> (const uint8_t *src, uint64_t offset)</td></tr>
<tr class="separator:a13845930a1d624c5cb26c56a0f480317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae038b605bd67e600ca73de74a33a0c5c"><td class="memItemLeft" align="right" valign="top">static const uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae038b605bd67e600ca73de74a33a0c5c">get_src_offset_uint64_t</a> (const uint8_t *src, uint64_t offset)</td></tr>
<tr class="separator:ae038b605bd67e600ca73de74a33a0c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7d50b1c62848a964e2e6893ad388a0"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#add7d50b1c62848a964e2e6893ad388a0">find_first_be_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:add7d50b1c62848a964e2e6893ad388a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0af5315381167d60b76e8a5225363c"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a4e0af5315381167d60b76e8a5225363c">find_first_be_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:a4e0af5315381167d60b76e8a5225363c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad38e80567cbf28c9b4edd70df60879"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a8ad38e80567cbf28c9b4edd70df60879">find_first_be_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a8ad38e80567cbf28c9b4edd70df60879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4790e44385e1784611ab65f499dbf6"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a4a4790e44385e1784611ab65f499dbf6">find_first_be_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a4a4790e44385e1784611ab65f499dbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b019db58ac4e565d4c9823599e5c5d"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a04b019db58ac4e565d4c9823599e5c5d">find_first_le_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:a04b019db58ac4e565d4c9823599e5c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede1840657dbb0a73b2c19962cbf143b"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aede1840657dbb0a73b2c19962cbf143b">find_first_le_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:aede1840657dbb0a73b2c19962cbf143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120d7f67ff5ac456de0be2fe39e3f30f"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a120d7f67ff5ac456de0be2fe39e3f30f">find_first_le_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a120d7f67ff5ac456de0be2fe39e3f30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2571feb4c66af60532cc40191746bdef"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a2571feb4c66af60532cc40191746bdef">find_first_le_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a2571feb4c66af60532cc40191746bdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdec5361e52e3152a02089c573b17e9"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aefdec5361e52e3152a02089c573b17e9">find_first_sub_be_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:aefdec5361e52e3152a02089c573b17e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5386f9b397536529c7e55c02b55b9405"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a5386f9b397536529c7e55c02b55b9405">find_first_sub_be_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:a5386f9b397536529c7e55c02b55b9405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93732cb6b6e0c896dc91d084ced1cd8"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ad93732cb6b6e0c896dc91d084ced1cd8">find_first_sub_be_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:ad93732cb6b6e0c896dc91d084ced1cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9026cb4df30ab38c4f2fb545bb851cff"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a9026cb4df30ab38c4f2fb545bb851cff">find_first_sub_be_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a9026cb4df30ab38c4f2fb545bb851cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb36cc8b5298fb5d314199b07e00ef9"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#acfb36cc8b5298fb5d314199b07e00ef9">find_first_sub_le_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:acfb36cc8b5298fb5d314199b07e00ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a2c17abc26abdb983880e8dacef6b9"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ac2a2c17abc26abdb983880e8dacef6b9">find_first_sub_le_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:ac2a2c17abc26abdb983880e8dacef6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b166dae7d455e1dc208795f9057745"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a57b166dae7d455e1dc208795f9057745">find_first_sub_le_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a57b166dae7d455e1dc208795f9057745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d0b7abc83143ad3b9444a9b55127c7"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a64d0b7abc83143ad3b9444a9b55127c7">find_first_sub_le_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a64d0b7abc83143ad3b9444a9b55127c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a33528182533acf79146513a56743ce"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a8a33528182533acf79146513a56743ce">find_last_be_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:a8a33528182533acf79146513a56743ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bb54cac8f8dc30a9223966bbb60ed0"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aa1bb54cac8f8dc30a9223966bbb60ed0">find_last_be_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:aa1bb54cac8f8dc30a9223966bbb60ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d92b8bd3117ca7d3cbbe5322b836c95"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a4d92b8bd3117ca7d3cbbe5322b836c95">find_last_be_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a4d92b8bd3117ca7d3cbbe5322b836c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6510d9bf6b9a5b2048c09a29018024cf"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a6510d9bf6b9a5b2048c09a29018024cf">find_last_be_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a6510d9bf6b9a5b2048c09a29018024cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acc1112c1514fc579460542b14de2d3"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a3acc1112c1514fc579460542b14de2d3">find_last_le_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:a3acc1112c1514fc579460542b14de2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc87020ae77f400ec62170a7e44e5174"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#acc87020ae77f400ec62170a7e44e5174">find_last_le_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:acc87020ae77f400ec62170a7e44e5174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766db57d70ab15cf1fecd3b71dd0223e"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a766db57d70ab15cf1fecd3b71dd0223e">find_last_le_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a766db57d70ab15cf1fecd3b71dd0223e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288ad6f6cb7a970b2426309abe9e4468"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a288ad6f6cb7a970b2426309abe9e4468">find_last_le_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a288ad6f6cb7a970b2426309abe9e4468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37407ac5c951e296f6f6be60ba6b0f5c"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a37407ac5c951e296f6f6be60ba6b0f5c">find_last_sub_be_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:a37407ac5c951e296f6f6be60ba6b0f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94e440e9a78865067bda743b1900f87"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ab94e440e9a78865067bda743b1900f87">find_last_sub_be_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:ab94e440e9a78865067bda743b1900f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e467656c8d00e936a3257dcc9b03922"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a4e467656c8d00e936a3257dcc9b03922">find_last_sub_be_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a4e467656c8d00e936a3257dcc9b03922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3a42b3405df6a8679550e74e7d42a7"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aee3a42b3405df6a8679550e74e7d42a7">find_last_sub_be_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:aee3a42b3405df6a8679550e74e7d42a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3a551ed31117b51598fc89bb699847"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aed3a551ed31117b51598fc89bb699847">find_last_sub_le_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:aed3a551ed31117b51598fc89bb699847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ce843e45711ccd5010387355306395"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae4ce843e45711ccd5010387355306395">find_last_sub_le_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:ae4ce843e45711ccd5010387355306395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bcc916f3cfcf483187188bf19b078f"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae8bcc916f3cfcf483187188bf19b078f">find_last_sub_le_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:ae8bcc916f3cfcf483187188bf19b078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f93951895bfd52527e35af02121587"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a81f93951895bfd52527e35af02121587">find_last_sub_le_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a81f93951895bfd52527e35af02121587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694cea4ed9bc8f846f38f7d4dae7f6a4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a694cea4ed9bc8f846f38f7d4dae7f6a4">has_next_be_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *pos, uint64_t last, uint8_t search)</td></tr>
<tr class="separator:a694cea4ed9bc8f846f38f7d4dae7f6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dbb18f410c8c0d3ae6fbfc7e76a29e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a01dbb18f410c8c0d3ae6fbfc7e76a29e">has_next_be_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *pos, uint64_t last, uint16_t search)</td></tr>
<tr class="separator:a01dbb18f410c8c0d3ae6fbfc7e76a29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9d213904c59824c9eee1f6a5895e2d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a7e9d213904c59824c9eee1f6a5895e2d">has_next_be_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *pos, uint64_t last, uint32_t search)</td></tr>
<tr class="separator:a7e9d213904c59824c9eee1f6a5895e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371a5d70cf821c8596ed4fb679dea541"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a371a5d70cf821c8596ed4fb679dea541">has_next_be_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *pos, uint64_t last, uint64_t search)</td></tr>
<tr class="separator:a371a5d70cf821c8596ed4fb679dea541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205cd87252bb1324e27a20d0cbb06833"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a205cd87252bb1324e27a20d0cbb06833">has_next_le_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *pos, uint64_t last, uint8_t search)</td></tr>
<tr class="separator:a205cd87252bb1324e27a20d0cbb06833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7ccef659844c077328c5528358e19f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a0c7ccef659844c077328c5528358e19f">has_next_le_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *pos, uint64_t last, uint16_t search)</td></tr>
<tr class="separator:a0c7ccef659844c077328c5528358e19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7a7c99ed1c5f705ad0b6f479e655b7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a8a7a7c99ed1c5f705ad0b6f479e655b7">has_next_le_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *pos, uint64_t last, uint32_t search)</td></tr>
<tr class="separator:a8a7a7c99ed1c5f705ad0b6f479e655b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e70adea568d635514e79fc475d4ac9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a51e70adea568d635514e79fc475d4ac9">has_next_le_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *pos, uint64_t last, uint64_t search)</td></tr>
<tr class="separator:a51e70adea568d635514e79fc475d4ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae536c6be7940d4b569a7364a5b2d1fef"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae536c6be7940d4b569a7364a5b2d1fef">has_next_sub_be_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint8_t search)</td></tr>
<tr class="separator:ae536c6be7940d4b569a7364a5b2d1fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3672a982e2607db4d83d2cd58f668326"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a3672a982e2607db4d83d2cd58f668326">has_next_sub_be_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint16_t search)</td></tr>
<tr class="separator:a3672a982e2607db4d83d2cd58f668326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8044081e5a4f8005a6193a80139d278"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ad8044081e5a4f8005a6193a80139d278">has_next_sub_be_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint32_t search)</td></tr>
<tr class="separator:ad8044081e5a4f8005a6193a80139d278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3103416b536c3a1ee9ca920d454bde88"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a3103416b536c3a1ee9ca920d454bde88">has_next_sub_be_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint64_t search)</td></tr>
<tr class="separator:a3103416b536c3a1ee9ca920d454bde88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb83c715d926cd5b8828f3687e6d247"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a2cb83c715d926cd5b8828f3687e6d247">has_next_sub_le_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint8_t search)</td></tr>
<tr class="separator:a2cb83c715d926cd5b8828f3687e6d247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bee3e41d002cab5a3df486a561ba218"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a2bee3e41d002cab5a3df486a561ba218">has_next_sub_le_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint16_t search)</td></tr>
<tr class="separator:a2bee3e41d002cab5a3df486a561ba218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9269a4759ec8a740134b9570ed80bb25"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a9269a4759ec8a740134b9570ed80bb25">has_next_sub_le_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint32_t search)</td></tr>
<tr class="separator:a9269a4759ec8a740134b9570ed80bb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d658799c81c9247b0519413451f96f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aa2d658799c81c9247b0519413451f96f">has_next_sub_le_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint64_t search)</td></tr>
<tr class="separator:aa2d658799c81c9247b0519413451f96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff94d1aef0a66ce07bab6bf0c0ddfaf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a9ff94d1aef0a66ce07bab6bf0c0ddfaf">has_prev_be_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t first, uint64_t *pos, uint8_t search)</td></tr>
<tr class="separator:a9ff94d1aef0a66ce07bab6bf0c0ddfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9d6d08137f75dcfb5ec38ceba39327"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#adf9d6d08137f75dcfb5ec38ceba39327">has_prev_be_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t first, uint64_t *pos, uint16_t search)</td></tr>
<tr class="separator:adf9d6d08137f75dcfb5ec38ceba39327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44792bd1a7dfaa45773e7e49c2f059f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aa44792bd1a7dfaa45773e7e49c2f059f">has_prev_be_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t first, uint64_t *pos, uint32_t search)</td></tr>
<tr class="separator:aa44792bd1a7dfaa45773e7e49c2f059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3967b3c5755b574df145f37cc360cee1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a3967b3c5755b574df145f37cc360cee1">has_prev_be_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t first, uint64_t *pos, uint64_t search)</td></tr>
<tr class="separator:a3967b3c5755b574df145f37cc360cee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369942143f492fcfdb5d4cb8d09636af"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a369942143f492fcfdb5d4cb8d09636af">has_prev_le_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t first, uint64_t *pos, uint8_t search)</td></tr>
<tr class="separator:a369942143f492fcfdb5d4cb8d09636af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a921636d8260e1802233cb472294967"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a4a921636d8260e1802233cb472294967">has_prev_le_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t first, uint64_t *pos, uint16_t search)</td></tr>
<tr class="separator:a4a921636d8260e1802233cb472294967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d50b9a44329e390b9707a79eaee7515"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a6d50b9a44329e390b9707a79eaee7515">has_prev_le_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t first, uint64_t *pos, uint32_t search)</td></tr>
<tr class="separator:a6d50b9a44329e390b9707a79eaee7515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1c5f32b1638258784709ab70ce0660"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a3f1c5f32b1638258784709ab70ce0660">has_prev_le_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t first, uint64_t *pos, uint64_t search)</td></tr>
<tr class="separator:a3f1c5f32b1638258784709ab70ce0660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7efa9aaa2547b44c075a27a9cb3f32"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a7e7efa9aaa2547b44c075a27a9cb3f32">has_prev_sub_be_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint8_t search)</td></tr>
<tr class="separator:a7e7efa9aaa2547b44c075a27a9cb3f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ec041ddd05ee0d729060cffbd4e0fa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ae9ec041ddd05ee0d729060cffbd4e0fa">has_prev_sub_be_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint16_t search)</td></tr>
<tr class="separator:ae9ec041ddd05ee0d729060cffbd4e0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876e42d68a25cdeb15c006f552fcd765"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a876e42d68a25cdeb15c006f552fcd765">has_prev_sub_be_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint32_t search)</td></tr>
<tr class="separator:a876e42d68a25cdeb15c006f552fcd765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea38c80485efd38b5a822209e051bcde"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aea38c80485efd38b5a822209e051bcde">has_prev_sub_be_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint64_t search)</td></tr>
<tr class="separator:aea38c80485efd38b5a822209e051bcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4204a4e9ba9f5006ab5db8657892959"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aa4204a4e9ba9f5006ab5db8657892959">has_prev_sub_le_uint8_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint8_t search)</td></tr>
<tr class="separator:aa4204a4e9ba9f5006ab5db8657892959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad141127aec007f7828525422bdc65031"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ad141127aec007f7828525422bdc65031">has_prev_sub_le_uint16_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint16_t search)</td></tr>
<tr class="separator:ad141127aec007f7828525422bdc65031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4317b5cffeea5a9ad8f9c7a70f7d0450"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a4317b5cffeea5a9ad8f9c7a70f7d0450">has_prev_sub_le_uint32_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint32_t search)</td></tr>
<tr class="separator:a4317b5cffeea5a9ad8f9c7a70f7d0450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24b6e68681756a0f468c32c8b5417f5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#af24b6e68681756a0f468c32c8b5417f5">has_prev_sub_le_uint64_t</a> (const uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint64_t search)</td></tr>
<tr class="separator:af24b6e68681756a0f468c32c8b5417f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e44ae9eadcee482c1855b747d6358c"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a12e44ae9eadcee482c1855b747d6358c">col_find_first_uint8_t</a> (const uint8_t *src, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:a12e44ae9eadcee482c1855b747d6358c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc2c47868ee9e9dffe7379c7f8fd29e"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a9bc2c47868ee9e9dffe7379c7f8fd29e">col_find_first_uint16_t</a> (const uint16_t *src, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:a9bc2c47868ee9e9dffe7379c7f8fd29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060162ef0c5dbab74e64de38a0860b80"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a060162ef0c5dbab74e64de38a0860b80">col_find_first_uint32_t</a> (const uint32_t *src, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a060162ef0c5dbab74e64de38a0860b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c50e9e74ef37f4caefd10066377bc0"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a91c50e9e74ef37f4caefd10066377bc0">col_find_first_uint64_t</a> (const uint64_t *src, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a91c50e9e74ef37f4caefd10066377bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7dbc1e230719b8f8f49a1aa94dbcb8"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a6b7dbc1e230719b8f8f49a1aa94dbcb8">col_find_first_sub_uint8_t</a> (const uint8_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:a6b7dbc1e230719b8f8f49a1aa94dbcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85834f491afccf5f0de5cb6753a88c06"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a85834f491afccf5f0de5cb6753a88c06">col_find_first_sub_uint16_t</a> (const uint16_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:a85834f491afccf5f0de5cb6753a88c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345781f96e038149bbaf9b4e0534098b"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a345781f96e038149bbaf9b4e0534098b">col_find_first_sub_uint32_t</a> (const uint32_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a345781f96e038149bbaf9b4e0534098b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d785297981e33a9512289df1d12239"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a98d785297981e33a9512289df1d12239">col_find_first_sub_uint64_t</a> (const uint64_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a98d785297981e33a9512289df1d12239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d238fa5fde3343a4afdac8526b56cb6"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a2d238fa5fde3343a4afdac8526b56cb6">col_find_last_uint8_t</a> (const uint8_t *src, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:a2d238fa5fde3343a4afdac8526b56cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add38dc5d840634493152d096f343834c"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#add38dc5d840634493152d096f343834c">col_find_last_uint16_t</a> (const uint16_t *src, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:add38dc5d840634493152d096f343834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a856f2a9247e81a61ac7b24aa40f64"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a36a856f2a9247e81a61ac7b24aa40f64">col_find_last_uint32_t</a> (const uint32_t *src, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a36a856f2a9247e81a61ac7b24aa40f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935c85cb10ebda40e452c105f14b844a"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a935c85cb10ebda40e452c105f14b844a">col_find_last_uint64_t</a> (const uint64_t *src, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:a935c85cb10ebda40e452c105f14b844a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0757f7e0bc8de1f3b741a6f741a1ed2"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aa0757f7e0bc8de1f3b741a6f741a1ed2">col_find_last_sub_uint8_t</a> (const uint8_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint8_t search)</td></tr>
<tr class="separator:aa0757f7e0bc8de1f3b741a6f741a1ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975b2d25802062ae897546bd6405415f"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a975b2d25802062ae897546bd6405415f">col_find_last_sub_uint16_t</a> (const uint16_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint16_t search)</td></tr>
<tr class="separator:a975b2d25802062ae897546bd6405415f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a8ff11b4649f80c47cfacc8ae509ea"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a47a8ff11b4649f80c47cfacc8ae509ea">col_find_last_sub_uint32_t</a> (const uint32_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint32_t search)</td></tr>
<tr class="separator:a47a8ff11b4649f80c47cfacc8ae509ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea36d88f4470f2e4f3cd3e89ff83e38b"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aea36d88f4470f2e4f3cd3e89ff83e38b">col_find_last_sub_uint64_t</a> (const uint64_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, uint64_t search)</td></tr>
<tr class="separator:aea36d88f4470f2e4f3cd3e89ff83e38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b601d184064d5839fa3464c838bbf0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ac3b601d184064d5839fa3464c838bbf0">col_has_next_uint8_t</a> (const uint8_t *src, uint64_t *pos, uint64_t last, uint8_t search)</td></tr>
<tr class="separator:ac3b601d184064d5839fa3464c838bbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38e5b8e8a3402ee2918c95970752069"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#ab38e5b8e8a3402ee2918c95970752069">col_has_next_uint16_t</a> (const uint16_t *src, uint64_t *pos, uint64_t last, uint16_t search)</td></tr>
<tr class="separator:ab38e5b8e8a3402ee2918c95970752069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b73c058b1e3837c9a718269cc6aab83"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a4b73c058b1e3837c9a718269cc6aab83">col_has_next_uint32_t</a> (const uint32_t *src, uint64_t *pos, uint64_t last, uint32_t search)</td></tr>
<tr class="separator:a4b73c058b1e3837c9a718269cc6aab83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c68c13bc3a83b34eeb6d0904312625"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aa6c68c13bc3a83b34eeb6d0904312625">col_has_next_uint64_t</a> (const uint64_t *src, uint64_t *pos, uint64_t last, uint64_t search)</td></tr>
<tr class="separator:aa6c68c13bc3a83b34eeb6d0904312625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0431d8346d39531a7e560aff2a14fc2d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a0431d8346d39531a7e560aff2a14fc2d">col_has_next_sub_uint8_t</a> (const uint8_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint8_t search)</td></tr>
<tr class="separator:a0431d8346d39531a7e560aff2a14fc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba670466b42fa6df09aacde5d361ac6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#afba670466b42fa6df09aacde5d361ac6">col_has_next_sub_uint16_t</a> (const uint16_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint16_t search)</td></tr>
<tr class="separator:afba670466b42fa6df09aacde5d361ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1abcb5160a7577009ef350f8e5c87f4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#af1abcb5160a7577009ef350f8e5c87f4">col_has_next_sub_uint32_t</a> (const uint32_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint32_t search)</td></tr>
<tr class="separator:af1abcb5160a7577009ef350f8e5c87f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bf35e94462a9213f0002d004c00fe8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#af0bf35e94462a9213f0002d004c00fe8">col_has_next_sub_uint64_t</a> (const uint64_t *src, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, uint64_t search)</td></tr>
<tr class="separator:af0bf35e94462a9213f0002d004c00fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda1c88b179adeee8b41de8c6eb3013d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#adda1c88b179adeee8b41de8c6eb3013d">col_has_prev_uint8_t</a> (const uint8_t *src, uint64_t first, uint64_t *pos, uint8_t search)</td></tr>
<tr class="separator:adda1c88b179adeee8b41de8c6eb3013d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba878a4e5aa3fbff5cb3a5fbc6e53d6b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#aba878a4e5aa3fbff5cb3a5fbc6e53d6b">col_has_prev_uint16_t</a> (const uint16_t *src, uint64_t first, uint64_t *pos, uint16_t search)</td></tr>
<tr class="separator:aba878a4e5aa3fbff5cb3a5fbc6e53d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9acfa062add7177fea3823642522aa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a2b9acfa062add7177fea3823642522aa">col_has_prev_uint32_t</a> (const uint32_t *src, uint64_t first, uint64_t *pos, uint32_t search)</td></tr>
<tr class="separator:a2b9acfa062add7177fea3823642522aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d46378ea446be90ad98008a6be991a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#af7d46378ea446be90ad98008a6be991a">col_has_prev_uint64_t</a> (const uint64_t *src, uint64_t first, uint64_t *pos, uint64_t search)</td></tr>
<tr class="separator:af7d46378ea446be90ad98008a6be991a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176f4d8b7e18c5e64058504f4e2eff0a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a176f4d8b7e18c5e64058504f4e2eff0a">col_has_prev_sub_uint8_t</a> (const uint8_t *src, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint8_t search)</td></tr>
<tr class="separator:a176f4d8b7e18c5e64058504f4e2eff0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde59b517769d5f29e12ea5f56ca0d1a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#afde59b517769d5f29e12ea5f56ca0d1a">col_has_prev_sub_uint16_t</a> (const uint16_t *src, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint16_t search)</td></tr>
<tr class="separator:afde59b517769d5f29e12ea5f56ca0d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd0a310917e1818ad17fc363617fc35"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a4cd0a310917e1818ad17fc363617fc35">col_has_prev_sub_uint32_t</a> (const uint32_t *src, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint32_t search)</td></tr>
<tr class="separator:a4cd0a310917e1818ad17fc363617fc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaa64f1f957c51b4a163f3e8194daec"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#abeaa64f1f957c51b4a163f3e8194daec">col_has_prev_sub_uint64_t</a> (const uint64_t *src, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, uint64_t search)</td></tr>
<tr class="separator:abeaa64f1f957c51b4a163f3e8194daec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894480911a2f9c57026388b3893c64db"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a894480911a2f9c57026388b3893c64db">parse_col_offset</a> (<a class="el" href="structmmfile__t.html">mmfile_t</a> *mf)</td></tr>
<tr class="separator:a894480911a2f9c57026388b3893c64db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052ad12bb8be4ecd923d01d4963f6129"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a052ad12bb8be4ecd923d01d4963f6129">parse_info_binsrc</a> (<a class="el" href="structmmfile__t.html">mmfile_t</a> *mf)</td></tr>
<tr class="separator:a052ad12bb8be4ecd923d01d4963f6129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107bc0758ebb05df2a8013ada2629698"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a107bc0758ebb05df2a8013ada2629698">parse_info_arrow</a> (<a class="el" href="structmmfile__t.html">mmfile_t</a> *mf)</td></tr>
<tr class="separator:a107bc0758ebb05df2a8013ada2629698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16247e7f04dd040d67acfa6e12582e9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a16247e7f04dd040d67acfa6e12582e9b">parse_info_feather</a> (<a class="el" href="structmmfile__t.html">mmfile_t</a> *mf)</td></tr>
<tr class="separator:a16247e7f04dd040d67acfa6e12582e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2602c6d1d5e5cafbf14e61af75591ebc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a2602c6d1d5e5cafbf14e61af75591ebc">mmap_binfile</a> (const char *file, <a class="el" href="structmmfile__t.html">mmfile_t</a> *mf)</td></tr>
<tr class="separator:a2602c6d1d5e5cafbf14e61af75591ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa56179105cfc9bbdeac924bad26375"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binsearch_8h.html#a9aa56179105cfc9bbdeac924bad26375">munmap_binfile</a> (<a class="el" href="structmmfile__t.html">mmfile_t</a> mf)</td></tr>
<tr class="separator:a9aa56179105cfc9bbdeac924bad26375"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The functions provided here allows to search unsigned integers in a binary file made of adjacent constant-length binary blocks sorted in ascending order.</p>
<p>For example, the first 4 bytes of each 8-bytes blocks below represent a uint32 in big-endian. The integers are sorted in ascending order.</p>
<ul>
<li>2f 81 f5 77 1a cc 7b 43</li>
<li>2f 81 f5 78 76 5f 63 b8</li>
<li>2f 81 f5 79 ca a9 a6 52</li>
</ul>
<p>This binary representation can be used to encode sortable key-value data, even with nested keys.</p>
<p>The xxd command-line application can be used to convert a binary file to hexdump and reverse. For example:</p>
<ul>
<li>xxd -p binaryfile.bin &gt; hexfile.txt</li>
<li>xxd -r -p hexfile.txt &gt; binaryfile.bin</li>
</ul>
<p>NOTE:</p><ul>
<li>The "_be_" or "BE" functions refer to source files sorted in Big-Endian.</li>
<li>The "_le_" or "LE" functions refer to source files sorted in Little-Endian. </li>
</ul>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a9de13eea7a6eb0fe4dd1c472b1e4b10c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COL_GET_ITEM_TASK&#160;&#160;&#160;x = *(src + middle);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a01fe1703a12ac2f98058173d69547fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COL_GET_SUB_ITEM_TASK&#160;&#160;&#160;x = ((*(src + middle) &gt;&gt; rshift) &amp; bitmask);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a54897c0419aa9258693d79c7c916d18a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COL_HAS_END_BLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;return (*(src + *pos) == search);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a921470c122edc1edf78f0d4687b9ae93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COL_HAS_SUB_END_BLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td>&#160;&#160;&#160;return (((*(src + *pos) &gt;&gt; rshift) &amp; bitmask) == search);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1055e111581a0445a20f87dbcd51cd1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_bytes_to</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> T bytes_##O##_to_##T(<span class="keyword">const</span> uint8_t *src, uint64_t i) \</div><div class="line">{ \</div><div class="line">    return order_##O##_##T(*((<span class="keyword">const</span> T *)(src + i))); \</div><div class="line">}</div></div><!-- fragment --><p>Convert bytes to the specified type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>Endiannes: be or le. </td></tr>
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4a73e66f47ba95b6a693234b8e556c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_col_find_first</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> uint64_t col_find_first_##T(<span class="keyword">const</span> T *src, uint64_t *first, uint64_t *last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a>(T) <a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">COL_GET_ITEM_TASK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_FIRST_INNER_CHECK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">COL_GET_ITEM_TASK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a> \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_ae844483cc5997bf2c85e55156fe9337e"><div class="ttname"><a href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_END_LOOP_BLOCK</div><div class="ttdef"><b>Definition:</b> binsearch.h:298</div></div>
<div class="ttc" id="binsearch_8h_html_a517f9a371a5746519af013bcfd98774a"><div class="ttname"><a href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_START_LOOP_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:291</div></div>
</div><!-- fragment --><p>Generic function to search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f3f7caaf555546c8258ab111304f504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_col_find_first_sub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> uint64_t col_find_first_sub_##T(<span class="keyword">const</span> T *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a>(T) <a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a>(T) <a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">COL_GET_SUB_ITEM_TASK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_FIRST_INNER_CHECK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">COL_GET_SUB_ITEM_TASK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a> \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_ae844483cc5997bf2c85e55156fe9337e"><div class="ttname"><a href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_END_LOOP_BLOCK</div><div class="ttdef"><b>Definition:</b> binsearch.h:298</div></div>
<div class="ttc" id="binsearch_8h_html_a517f9a371a5746519af013bcfd98774a"><div class="ttname"><a href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_START_LOOP_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:291</div></div>
<div class="ttc" id="binsearch_8h_html_ad0fddeeba1901267a55ab890fa5e0d38"><div class="ttname"><a href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a></div><div class="ttdeci">#define SUB_ITEM_VARS(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:309</div></div>
</div><!-- fragment --><p>Generic function to search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4181ee1218ce7b4c942af44a0727c56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_col_find_last</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> uint64_t col_find_last_##T(<span class="keyword">const</span> T *src, uint64_t *first, uint64_t *last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a>(T) <a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">COL_GET_ITEM_TASK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_LAST_INNER_CHECK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">COL_GET_ITEM_TASK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a> \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_ae844483cc5997bf2c85e55156fe9337e"><div class="ttname"><a href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_END_LOOP_BLOCK</div><div class="ttdef"><b>Definition:</b> binsearch.h:298</div></div>
<div class="ttc" id="binsearch_8h_html_a517f9a371a5746519af013bcfd98774a"><div class="ttname"><a href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_START_LOOP_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:291</div></div>
</div><!-- fragment --><p>Generic function to search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3494bf01e1976617617fe8f37a48cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_col_find_last_sub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> uint64_t col_find_last_sub_##T(<span class="keyword">const</span> T *src, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a>(T) <a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a>(T) <a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">COL_GET_SUB_ITEM_TASK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_LAST_INNER_CHECK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">COL_GET_SUB_ITEM_TASK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a> \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_ae844483cc5997bf2c85e55156fe9337e"><div class="ttname"><a href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_END_LOOP_BLOCK</div><div class="ttdef"><b>Definition:</b> binsearch.h:298</div></div>
<div class="ttc" id="binsearch_8h_html_a517f9a371a5746519af013bcfd98774a"><div class="ttname"><a href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_START_LOOP_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:291</div></div>
<div class="ttc" id="binsearch_8h_html_ad0fddeeba1901267a55ab890fa5e0d38"><div class="ttname"><a href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a></div><div class="ttdeci">#define SUB_ITEM_VARS(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:309</div></div>
</div><!-- fragment --><p>Generic function to search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab894f514c256050cef02cb4251ec476e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_col_has_next</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> <span class="keywordtype">bool</span> col_has_next_##T(<span class="keyword">const</span> T *src, uint64_t *pos, uint64_t last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#a54897c0419aa9258693d79c7c916d18a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a54897c0419aa9258693d79c7c916d18a">HAS_NEXT_START_BLOCK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#a54897c0419aa9258693d79c7c916d18a">COL_HAS_END_BLOCK</a>(T) \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_a54897c0419aa9258693d79c7c916d18a"><div class="ttname"><a href="binsearch_8h.html#a54897c0419aa9258693d79c7c916d18a">COL_HAS_END_BLOCK</a></div><div class="ttdeci">#define COL_HAS_END_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:369</div></div>
</div><!-- fragment --><p>Generic function to check if the next item still matches the search value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb283d99efb97a73394876f9a9b4b60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_col_has_next_sub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> <span class="keywordtype">bool</span> col_has_next_sub_##T(<span class="keyword">const</span> T *src, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">HAS_NEXT_START_BLOCK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a>(T) <a class="code" href="binsearch_8h.html#a921470c122edc1edf78f0d4687b9ae93">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a921470c122edc1edf78f0d4687b9ae93">COL_HAS_SUB_END_BLOCK</a>(T) \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_a921470c122edc1edf78f0d4687b9ae93"><div class="ttname"><a href="binsearch_8h.html#a921470c122edc1edf78f0d4687b9ae93">COL_HAS_SUB_END_BLOCK</a></div><div class="ttdeci">#define COL_HAS_SUB_END_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:375</div></div>
<div class="ttc" id="binsearch_8h_html_ad0fddeeba1901267a55ab890fa5e0d38"><div class="ttname"><a href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a></div><div class="ttdeci">#define SUB_ITEM_VARS(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:309</div></div>
</div><!-- fragment --><p>Generic function to check if the next item still matches the search value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8919f8db2e76a1215fb94d2f35543d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_col_has_prev</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> <span class="keywordtype">bool</span> col_has_prev_##T(<span class="keyword">const</span> T *src, uint64_t first, uint64_t *pos, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#a54897c0419aa9258693d79c7c916d18a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a54897c0419aa9258693d79c7c916d18a">HAS_PREV_START_BLOCK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#a54897c0419aa9258693d79c7c916d18a">COL_HAS_END_BLOCK</a>(T) \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_a54897c0419aa9258693d79c7c916d18a"><div class="ttname"><a href="binsearch_8h.html#a54897c0419aa9258693d79c7c916d18a">COL_HAS_END_BLOCK</a></div><div class="ttdeci">#define COL_HAS_END_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:369</div></div>
</div><!-- fragment --><p>Generic function to check if the previous item still matches the search value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ad3ee7b0a6df6401b85f3241b03e0b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_col_has_prev_sub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> <span class="keywordtype">bool</span> col_has_prev_sub_##T(<span class="keyword">const</span> T *src, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">HAS_PREV_START_BLOCK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a>(T) <a class="code" href="binsearch_8h.html#a921470c122edc1edf78f0d4687b9ae93">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a921470c122edc1edf78f0d4687b9ae93">COL_HAS_SUB_END_BLOCK</a>(T) \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_a921470c122edc1edf78f0d4687b9ae93"><div class="ttname"><a href="binsearch_8h.html#a921470c122edc1edf78f0d4687b9ae93">COL_HAS_SUB_END_BLOCK</a></div><div class="ttdeci">#define COL_HAS_SUB_END_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:375</div></div>
<div class="ttc" id="binsearch_8h_html_ad0fddeeba1901267a55ab890fa5e0d38"><div class="ttname"><a href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a></div><div class="ttdeci">#define SUB_ITEM_VARS(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:309</div></div>
</div><!-- fragment --><p>Generic function to check if the previous item still matches the search value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bc7a72ed8e1d15f4cd07ece93031a90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_find_first</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> uint64_t find_first_##O##_##T(<span class="keyword">const</span> uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a>(T) <a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">GET_ITEM_TASK</a>(O, T) <a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">FIND_FIRST_INNER_CHECK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">GET_ITEM_TASK</a>(O, T) <a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a> \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_ae844483cc5997bf2c85e55156fe9337e"><div class="ttname"><a href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_END_LOOP_BLOCK</div><div class="ttdef"><b>Definition:</b> binsearch.h:298</div></div>
<div class="ttc" id="binsearch_8h_html_a1f14b70467af041f6e5777506e4d63a1"><div class="ttname"><a href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">GET_ITEM_TASK</a></div><div class="ttdeci">#define GET_ITEM_TASK(O, T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:314</div></div>
<div class="ttc" id="binsearch_8h_html_a517f9a371a5746519af013bcfd98774a"><div class="ttname"><a href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_START_LOOP_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:291</div></div>
</div><!-- fragment --><p>Generic function to search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>Endiannes: be or le. </td></tr>
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace1ea2763f11924b67b80cbd6bfee3ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_find_first_sub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> uint64_t find_first_sub_##O##_##T(<span class="keyword">const</span> uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a>(T) <a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a>(T) <a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">GET_SUB_ITEM_TASK</a>(O, T) <a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">FIND_FIRST_INNER_CHECK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">GET_SUB_ITEM_TASK</a>(O, T) <a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a> \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_a31b65a18c12c4857a2b059b1aa819675"><div class="ttname"><a href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">GET_SUB_ITEM_TASK</a></div><div class="ttdeci">#define GET_SUB_ITEM_TASK(O, T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:320</div></div>
<div class="ttc" id="binsearch_8h_html_ae844483cc5997bf2c85e55156fe9337e"><div class="ttname"><a href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_END_LOOP_BLOCK</div><div class="ttdef"><b>Definition:</b> binsearch.h:298</div></div>
<div class="ttc" id="binsearch_8h_html_a517f9a371a5746519af013bcfd98774a"><div class="ttname"><a href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_START_LOOP_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:291</div></div>
<div class="ttc" id="binsearch_8h_html_ad0fddeeba1901267a55ab890fa5e0d38"><div class="ttname"><a href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a></div><div class="ttdeci">#define SUB_ITEM_VARS(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:309</div></div>
</div><!-- fragment --><p>Generic function to search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>Endiannes: be or le. </td></tr>
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6aa11401effbe93bd348d8c947027991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_find_last</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> uint64_t find_last_##O##_##T(<span class="keyword">const</span> uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *first, uint64_t *last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a>(T) <a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">GET_ITEM_TASK</a>(O, T) <a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">FIND_LAST_INNER_CHECK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">GET_ITEM_TASK</a>(O, T) <a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a> \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_ae844483cc5997bf2c85e55156fe9337e"><div class="ttname"><a href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_END_LOOP_BLOCK</div><div class="ttdef"><b>Definition:</b> binsearch.h:298</div></div>
<div class="ttc" id="binsearch_8h_html_a1f14b70467af041f6e5777506e4d63a1"><div class="ttname"><a href="binsearch_8h.html#a1f14b70467af041f6e5777506e4d63a1">GET_ITEM_TASK</a></div><div class="ttdeci">#define GET_ITEM_TASK(O, T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:314</div></div>
<div class="ttc" id="binsearch_8h_html_a517f9a371a5746519af013bcfd98774a"><div class="ttname"><a href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_START_LOOP_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:291</div></div>
</div><!-- fragment --><p>Generic function to search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>Endiannes: be or le. </td></tr>
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee1e8903559637ba785c109e36422ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_find_last_sub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> uint64_t find_last_sub_##O##_##T(<span class="keyword">const</span> uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *first, uint64_t *last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a>(T) <a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a>(T) <a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">GET_SUB_ITEM_TASK</a>(O, T) <a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">FIND_LAST_INNER_CHECK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">GET_SUB_ITEM_TASK</a>(O, T) <a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a> \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_a31b65a18c12c4857a2b059b1aa819675"><div class="ttname"><a href="binsearch_8h.html#a31b65a18c12c4857a2b059b1aa819675">GET_SUB_ITEM_TASK</a></div><div class="ttdeci">#define GET_SUB_ITEM_TASK(O, T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:320</div></div>
<div class="ttc" id="binsearch_8h_html_ae844483cc5997bf2c85e55156fe9337e"><div class="ttname"><a href="binsearch_8h.html#ae844483cc5997bf2c85e55156fe9337e">FIND_END_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_END_LOOP_BLOCK</div><div class="ttdef"><b>Definition:</b> binsearch.h:298</div></div>
<div class="ttc" id="binsearch_8h_html_a517f9a371a5746519af013bcfd98774a"><div class="ttname"><a href="binsearch_8h.html#a517f9a371a5746519af013bcfd98774a">FIND_START_LOOP_BLOCK</a></div><div class="ttdeci">#define FIND_START_LOOP_BLOCK(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:291</div></div>
<div class="ttc" id="binsearch_8h_html_ad0fddeeba1901267a55ab890fa5e0d38"><div class="ttname"><a href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a></div><div class="ttdeci">#define SUB_ITEM_VARS(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:309</div></div>
</div><!-- fragment --><p>Generic function to search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>Endiannes: be or le. </td></tr>
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6664e238bce881a60395ed2688158228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_get_src_offset</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> <span class="keyword">const</span> T *get_src_offset_##T(<span class="keyword">const</span> uint8_t *src, uint64_t offset) \</div><div class="line">{ \</div><div class="line">    return <a class="code" href="binsearch_8h.html#af4eb5c24939d2b9ff2f1709972d15e70">get_src_offset</a>(T, src, offset); \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_af4eb5c24939d2b9ff2f1709972d15e70"><div class="ttname"><a href="binsearch_8h.html#af4eb5c24939d2b9ff2f1709972d15e70">get_src_offset</a></div><div class="ttdeci">#define get_src_offset(T, src, offset)</div><div class="ttdef"><b>Definition:</b> binsearch.h:224</div></div>
</div><!-- fragment --><p>Define functions to return a pointer to the offset position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e99e4a289b381504aaee46fdb173841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_has_next</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> <span class="keywordtype">bool</span> has_next_##O##_##T(<span class="keyword">const</span> uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t *pos, uint64_t last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#a117e255e20440263d826a32e6c05321e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a117e255e20440263d826a32e6c05321e">HAS_NEXT_START_BLOCK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#a117e255e20440263d826a32e6c05321e">HAS_END_BLOCK</a>(O, T) \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_a117e255e20440263d826a32e6c05321e"><div class="ttname"><a href="binsearch_8h.html#a117e255e20440263d826a32e6c05321e">HAS_END_BLOCK</a></div><div class="ttdeci">#define HAS_END_BLOCK(O, T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:366</div></div>
</div><!-- fragment --><p>Generic function to check if the next item still matches the search value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>Endiannes: be or le. </td></tr>
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42db86bef619b154edfc394d83bac0e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_has_next_sub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> <span class="keywordtype">bool</span> has_next_sub_##O##_##T(<span class="keyword">const</span> uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t *pos, uint64_t last, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">HAS_NEXT_START_BLOCK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a>(T) <a class="code" href="binsearch_8h.html#afa9a64a545a1575318d354f8324b0341">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#afa9a64a545a1575318d354f8324b0341">HAS_SUB_END_BLOCK</a>(O, T) \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_ad0fddeeba1901267a55ab890fa5e0d38"><div class="ttname"><a href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a></div><div class="ttdeci">#define SUB_ITEM_VARS(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:309</div></div>
<div class="ttc" id="binsearch_8h_html_afa9a64a545a1575318d354f8324b0341"><div class="ttname"><a href="binsearch_8h.html#afa9a64a545a1575318d354f8324b0341">HAS_SUB_END_BLOCK</a></div><div class="ttdeci">#define HAS_SUB_END_BLOCK(O, T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:372</div></div>
</div><!-- fragment --><p>Generic function to check if the next item still matches the search value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>Endiannes: be or le. </td></tr>
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1486e08119eaa1295b3afbd3e970c6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_has_prev</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> <span class="keywordtype">bool</span> has_prev_##O##_##T(<span class="keyword">const</span> uint8_t *src, uint64_t blklen, uint64_t blkpos, uint64_t first, uint64_t *pos, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#a117e255e20440263d826a32e6c05321e">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#a117e255e20440263d826a32e6c05321e">HAS_PREV_START_BLOCK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#a117e255e20440263d826a32e6c05321e">HAS_END_BLOCK</a>(O, T) \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_a117e255e20440263d826a32e6c05321e"><div class="ttname"><a href="binsearch_8h.html#a117e255e20440263d826a32e6c05321e">HAS_END_BLOCK</a></div><div class="ttdeci">#define HAS_END_BLOCK(O, T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:366</div></div>
</div><!-- fragment --><p>Generic function to check if the previous item still matches the search value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>Endiannes: be or le. </td></tr>
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c4ea3b1de6b014d7e32c7d297d28a4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define define_has_prev_sub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"> \</div><div class="line">static <span class="keyword">inline</span> <span class="keywordtype">bool</span> has_prev_sub_##O##_##T(<span class="keyword">const</span> uint8_t *src, uint64_t blklen, uint64_t blkpos, uint8_t bitstart, uint8_t bitend, uint64_t first, uint64_t *pos, T search) \</div><div class="line">{ <a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">HAS_PREV_START_BLOCK \</a></div><div class="line"><a class="code" href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a>(T) <a class="code" href="binsearch_8h.html#afa9a64a545a1575318d354f8324b0341">\</a></div><div class="line"><a class="code" href="binsearch_8h.html#afa9a64a545a1575318d354f8324b0341">HAS_SUB_END_BLOCK</a>(O, T) \</div><div class="line">}</div><div class="ttc" id="binsearch_8h_html_ad0fddeeba1901267a55ab890fa5e0d38"><div class="ttname"><a href="binsearch_8h.html#ad0fddeeba1901267a55ab890fa5e0d38">SUB_ITEM_VARS</a></div><div class="ttdeci">#define SUB_ITEM_VARS(T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:309</div></div>
<div class="ttc" id="binsearch_8h_html_afa9a64a545a1575318d354f8324b0341"><div class="ttname"><a href="binsearch_8h.html#afa9a64a545a1575318d354f8324b0341">HAS_SUB_END_BLOCK</a></div><div class="ttdeci">#define HAS_SUB_END_BLOCK(O, T)</div><div class="ttdef"><b>Definition:</b> binsearch.h:372</div></div>
</div><!-- fragment --><p>Generic function to check if the previous item still matches the search value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>Endiannes: be or le. </td></tr>
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae844483cc5997bf2c85e55156fe9337e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIND_END_LOOP_BLOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> (x == search) \</div><div class="line">    { \</div><div class="line">        return middle; \</div><div class="line">    } \</div><div class="line">    if (*first &gt; 0) \</div><div class="line">    { \</div><div class="line">        --(*first); \</div><div class="line">    } \</div><div class="line">    return notfound;</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1a49b63792e4d038a3205402c18427c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIND_FIRST_INNER_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> (x &lt; search) { \</div><div class="line">            *first = middle; \</div><div class="line">            ++(*first); \</div><div class="line">        } \</div><div class="line">        else \</div><div class="line">        { \</div><div class="line">            *last = middle; \</div><div class="line">        } \</div><div class="line">    } \</div><div class="line">    middle = *first;</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a72baf12ebb2593d9f0961b0e11184996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIND_LAST_INNER_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> (x &gt; search) { \</div><div class="line">            *last = middle; \</div><div class="line">        } \</div><div class="line">        else \</div><div class="line">        { \</div><div class="line">            *first = middle; \</div><div class="line">            ++(*first); \</div><div class="line">        } \</div><div class="line">    } \</div><div class="line">    middle = *first; \</div><div class="line">    --middle;</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a517f9a371a5746519af013bcfd98774a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIND_START_LOOP_BLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">uint64_t middle, notfound = *last; \</div><div class="line">    T x; \</div><div class="line">    while (*first &lt; *last) \</div><div class="line">    { \</div><div class="line">        middle = <a class="code" href="binsearch_8h.html#acfa58740ee6cbd77b5c7b6abd937226e">get_middle_point</a>(*first, *last); \</div><div class="ttc" id="binsearch_8h_html_acfa58740ee6cbd77b5c7b6abd937226e"><div class="ttname"><a href="binsearch_8h.html#acfa58740ee6cbd77b5c7b6abd937226e">get_middle_point</a></div><div class="ttdeci">#define get_middle_point(first, last)</div><div class="ttdef"><b>Definition:</b> binsearch.h:213</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2c97ce65cada1ea153d17cd4bc61945b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define get_address</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blklen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blkpos, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((blklen) * (item)) + (blkpos))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the absolute file address position of the specified item (binary block).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the value to search inside a binary block. </td></tr>
    <tr><td class="paramname">item</td><td>Item number to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>First byte position of the specified item number. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f14b70467af041f6e5777506e4d63a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_ITEM_TASK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;x = <a class="el" href="binsearch_8h.html#a1a8b38d5244744dc6543471183eea68c">GET_MIDDLE_BLOCK</a>(O, T);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a8b38d5244744dc6543471183eea68c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_MIDDLE_BLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;order_##O##_##T(*(<a class="el" href="binsearch_8h.html#af4eb5c24939d2b9ff2f1709972d15e70">get_src_offset</a>(T, src, <a class="el" href="binsearch_8h.html#a2c97ce65cada1ea153d17cd4bc61945b">get_address</a>(blklen, blkpos, middle))))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acfa58740ee6cbd77b5c7b6abd937226e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define get_middle_point</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">first, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">last&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((first) + (((last) - (first)) &gt;&gt; 1))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the middle point between two values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First point (smaller point). </td></tr>
    <tr><td class="paramname">last</td><td>Last point (bigger point).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Middle point. </dd></dl>

</div>
</div>
<a class="anchor" id="a641b20c4420de81ffd7a891bd3d6e949"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_POS_BLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;order_##O##_##T(*(<a class="el" href="binsearch_8h.html#af4eb5c24939d2b9ff2f1709972d15e70">get_src_offset</a>(T, src, <a class="el" href="binsearch_8h.html#a2c97ce65cada1ea153d17cd4bc61945b">get_address</a>(blklen, blkpos, *pos))))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4eb5c24939d2b9ff2f1709972d15e70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define get_src_offset</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">offset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((const T *)((src) + (offset)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pointer at the specified byte offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Unsigned integer type, one of: uint8_t, uint16_t, uint32_t, uint64_t. </td></tr>
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a31b65a18c12c4857a2b059b1aa819675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_SUB_ITEM_TASK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;x = ((<a class="el" href="binsearch_8h.html#a1a8b38d5244744dc6543471183eea68c">GET_MIDDLE_BLOCK</a>(O, T) &gt;&gt; rshift) &amp; bitmask);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a117e255e20440263d826a32e6c05321e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAS_END_BLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;return (<a class="el" href="binsearch_8h.html#a641b20c4420de81ffd7a891bd3d6e949">GET_POS_BLOCK</a>(O, T) == search);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa43375f749044ed34cbac15d8a9ad351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAS_NEXT_START_BLOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> (*pos &gt;= (last - 1)) \</div><div class="line">    { \</div><div class="line">        return 0; \</div><div class="line">    } \</div><div class="line">    ++(*pos);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a20ed7fb62474d143e8046028d4a73ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAS_PREV_START_BLOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> (*pos &lt;= first) { \</div><div class="line">        return 0; \</div><div class="line">    } \</div><div class="line">    --(*pos);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afa9a64a545a1575318d354f8324b0341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAS_SUB_END_BLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">O, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;return (((<a class="el" href="binsearch_8h.html#a641b20c4420de81ffd7a891bd3d6e949">GET_POS_BLOCK</a>(O, T) &gt;&gt; rshift) &amp; bitmask) == search);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a83dc415ae5e205183f0488b46228c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAXCOLS&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abce4fd0dab9e96707e24efb31c2dc85f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define order_be_uint16_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(bswap_16(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae45175a282efa75e0bcaedaab16901ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define order_be_uint32_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(bswap_32(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2142afb598f7581859021b5006d8ef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define order_be_uint64_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(bswap_64(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ffaace8b8aba6cc164abbcd02108daf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define order_be_uint8_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return BE uint8_t </p>

</div>
</div>
<a class="anchor" id="af522ff60f5c32f6f45f3f3c4480fc60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define order_le_uint16_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a389753ec47839aa25004f497aa345af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define order_le_uint32_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d23a5e7b0dccb18a7b7f95968791b7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define order_le_uint64_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a52f865e71b74172e5f252512e04a67c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define order_le_uint8_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad0fddeeba1901267a55ab890fa5e0d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SUB_ITEM_VARS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">T bitmask = ((T)1 &lt;&lt; (bitend - bitstart)); \</div><div class="line">    bitmask ^= (bitmask - 1); \</div><div class="line">    const uint8_t rshift = (((uint8_t)(<span class="keyword">sizeof</span>(T) * 8) - 1) - bitend);</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab7225c40735b7e72695c2dcd522601d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmmfile__t.html">mmfile_t</a>  <a class="el" href="structmmfile__t.html">mmfile_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Struct containing the memory mapped file info. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0a62801cb588f747292d4dddbc99b240"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t bytes_be_to_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert bytes in "be" format to uint16_t . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">i</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted number </dd></dl>

</div>
</div>
<a class="anchor" id="ac1a2b647ad635b560261ff697a2dfe35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t bytes_be_to_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert bytes in "be" format to uint32_t . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">i</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted number </dd></dl>

</div>
</div>
<a class="anchor" id="a44265545f56907db0e66a59650d13525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t bytes_be_to_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert bytes in "be" format to uint64_t . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">i</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted number </dd></dl>

</div>
</div>
<a class="anchor" id="a6ba84555aa4d82113999e8a861348068"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t bytes_be_to_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert bytes in "be" format to uint8_t . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">i</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted number </dd></dl>

</div>
</div>
<a class="anchor" id="a89a18b3358cca8c7924a50a18aa802ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t bytes_le_to_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert bytes in "le" format to uint16_t . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">i</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted number </dd></dl>

</div>
</div>
<a class="anchor" id="a2e6fc8c7fd52cffa0afbebe3913fdb47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t bytes_le_to_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert bytes in "le" format to uint32_t . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">i</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted number </dd></dl>

</div>
</div>
<a class="anchor" id="ab80b5065ce2833b1a99cb81645623ba7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t bytes_le_to_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert bytes in "le" format to uint64_t . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">i</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted number </dd></dl>

</div>
</div>
<a class="anchor" id="ae17292f2e6088f00fb6df4afc8bbd6be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t bytes_le_to_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert bytes in "le" format to uint8_t . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">i</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted number </dd></dl>

</div>
</div>
<a class="anchor" id="a85834f491afccf5f0de5cb6753a88c06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_first_sub_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a345781f96e038149bbaf9b4e0534098b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_first_sub_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a98d785297981e33a9512289df1d12239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_first_sub_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b7dbc1e230719b8f8f49a1aa94dbcb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_first_sub_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bc2c47868ee9e9dffe7379c7f8fd29e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_first_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a060162ef0c5dbab74e64de38a0860b80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_first_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a91c50e9e74ef37f4caefd10066377bc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_first_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a12e44ae9eadcee482c1855b747d6358c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_first_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a975b2d25802062ae897546bd6405415f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_last_sub_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a47a8ff11b4649f80c47cfacc8ae509ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_last_sub_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="aea36d88f4470f2e4f3cd3e89ff83e38b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_last_sub_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0757f7e0bc8de1f3b741a6f741a1ed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_last_sub_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="add38dc5d840634493152d096f343834c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_last_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a36a856f2a9247e81a61ac7b24aa40f64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_last_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a935c85cb10ebda40e452c105f14b844a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_last_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d238fa5fde3343a4afdac8526b56cb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t col_find_last_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory buffer containing contiguos blocks of unsigned integers of the same type. The values must be encoded in Little-Endian format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="afba670466b42fa6df09aacde5d361ac6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_next_sub_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_first_sub_uint16_t to get the next elements that still satisfy the search. The item returned by col_find_first_sub_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af1abcb5160a7577009ef350f8e5c87f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_next_sub_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_first_sub_uint32_t to get the next elements that still satisfy the search. The item returned by col_find_first_sub_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af0bf35e94462a9213f0002d004c00fe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_next_sub_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_first_sub_uint64_t to get the next elements that still satisfy the search. The item returned by col_find_first_sub_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0431d8346d39531a7e560aff2a14fc2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_next_sub_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_first_sub_uint8_t to get the next elements that still satisfy the search. The item returned by col_find_first_sub_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab38e5b8e8a3402ee2918c95970752069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_next_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_first_uint16_t to get the next elements that still satisfy the search. The item returned by col_find_first_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b73c058b1e3837c9a718269cc6aab83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_next_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_first_uint32_t to get the next elements that still satisfy the search. The item returned by col_find_first_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6c68c13bc3a83b34eeb6d0904312625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_next_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_first_uint64_t to get the next elements that still satisfy the search. The item returned by col_find_first_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3b601d184064d5839fa3464c838bbf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_next_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_first_uint8_t to get the next elements that still satisfy the search. The item returned by col_find_first_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afde59b517769d5f29e12ea5f56ca0d1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_prev_sub_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_last_sub_uint16_t to get the previous elements that still satisfy the search. The item returned by col_find_last_sub_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cd0a310917e1818ad17fc363617fc35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_prev_sub_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_last_sub_uint32_t to get the previous elements that still satisfy the search. The item returned by col_find_last_sub_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abeaa64f1f957c51b4a163f3e8194daec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_prev_sub_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_last_sub_uint64_t to get the previous elements that still satisfy the search. The item returned by col_find_last_sub_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a176f4d8b7e18c5e64058504f4e2eff0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_prev_sub_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_last_sub_uint8_t to get the previous elements that still satisfy the search. The item returned by col_find_last_sub_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aba878a4e5aa3fbff5cb3a5fbc6e53d6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_prev_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_last_uint16_t to get the previous elements that still satisfy the search. The item returned by col_find_last_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b9acfa062add7177fea3823642522aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_prev_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_last_uint32_t to get the previous elements that still satisfy the search. The item returned by col_find_last_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af7d46378ea446be90ad98008a6be991a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_prev_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_last_uint64_t to get the previous elements that still satisfy the search. The item returned by col_find_last_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adda1c88b179adeee8b41de8c6eb3013d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool col_has_prev_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory buffer containing contiguos blocks of sorted binary data of the same type still matches the search value. The values must be encoded in Little-Endian format and sorted in ascending order. This function can be used after find_last_uint8_t to get the previous elements that still satisfy the search. The item returned by col_find_last_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e0af5315381167d60b76e8a5225363c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_be_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ad38e80567cbf28c9b4edd70df60879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_be_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a4790e44385e1784611ab65f499dbf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_be_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="add7d50b1c62848a964e2e6893ad388a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_be_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="aede1840657dbb0a73b2c19962cbf143b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_le_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a120d7f67ff5ac456de0be2fe39e3f30f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_le_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a2571feb4c66af60532cc40191746bdef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_le_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a04b019db58ac4e565d4c9823599e5c5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_le_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a5386f9b397536529c7e55c02b55b9405"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_sub_be_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="ad93732cb6b6e0c896dc91d084ced1cd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_sub_be_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a9026cb4df30ab38c4f2fb545bb851cff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_sub_be_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="aefdec5361e52e3152a02089c573b17e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_sub_be_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2a2c17abc26abdb983880e8dacef6b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_sub_le_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a57b166dae7d455e1dc208795f9057745"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_sub_le_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a64d0b7abc83143ad3b9444a9b55127c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_sub_le_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="acfb36cc8b5298fb5d314199b07e00ef9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_first_sub_le_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1bb54cac8f8dc30a9223966bbb60ed0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_be_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d92b8bd3117ca7d3cbbe5322b836c95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_be_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a6510d9bf6b9a5b2048c09a29018024cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_be_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a33528182533acf79146513a56743ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_be_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="acc87020ae77f400ec62170a7e44e5174"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_le_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a766db57d70ab15cf1fecd3b71dd0223e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_le_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a288ad6f6cb7a970b2426309abe9e4468"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_le_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a3acc1112c1514fc579460542b14de2d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_le_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="ab94e440e9a78865067bda743b1900f87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_sub_be_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e467656c8d00e936a3257dcc9b03922"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_sub_be_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="aee3a42b3405df6a8679550e74e7d42a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_sub_be_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a37407ac5c951e296f6f6be60ba6b0f5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_sub_be_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "be" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4ce843e45711ccd5010387355306395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_sub_le_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8bcc916f3cfcf483187188bf19b078f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_sub_le_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a81f93951895bfd52527e35af02121587"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_sub_le_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="aed3a551ed31117b51598fc89bb699847"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t find_last_sub_le_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data. The values in the file must be encoded in "le" format and sorted in ascending order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>Pointer to the element from where to start the search (min value = 0). </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item number if notfound or (last + 1) if not notfound. </dd></dl>

</div>
</div>
<a class="anchor" id="a77e221ab4a623997b0e4b3e87ff7adf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const uint16_t* get_src_offset_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the offset position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">offset</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a13845930a1d624c5cb26c56a0f480317"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const uint32_t* get_src_offset_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the offset position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">offset</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ae038b605bd67e600ca73de74a33a0c5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const uint64_t* get_src_offset_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the offset position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">offset</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

</div>
</div>
<a class="anchor" id="aa95e4f6be694f7cddec74cbe67364332"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const uint8_t* get_src_offset_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the offset position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">offset</td><td>Start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a01dbb18f410c8c0d3ae6fbfc7e76a29e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_be_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_first_uint16_t to get the next elements that still satisfy the search. The item returned by find_first_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e9d213904c59824c9eee1f6a5895e2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_be_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_first_uint32_t to get the next elements that still satisfy the search. The item returned by find_first_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a371a5d70cf821c8596ed4fb679dea541"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_be_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_first_uint64_t to get the next elements that still satisfy the search. The item returned by find_first_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a694cea4ed9bc8f846f38f7d4dae7f6a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_be_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_first_uint8_t to get the next elements that still satisfy the search. The item returned by find_first_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c7ccef659844c077328c5528358e19f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_le_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_first_uint16_t to get the next elements that still satisfy the search. The item returned by find_first_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a7a7c99ed1c5f705ad0b6f479e655b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_le_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_first_uint32_t to get the next elements that still satisfy the search. The item returned by find_first_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a51e70adea568d635514e79fc475d4ac9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_le_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_first_uint64_t to get the next elements that still satisfy the search. The item returned by find_first_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a205cd87252bb1324e27a20d0cbb06833"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_le_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_first_uint8_t to get the next elements that still satisfy the search. The item returned by find_first_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3672a982e2607db4d83d2cd58f668326"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_sub_be_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_first_sub_uint16_t to get the next elements that still satisfy the search. The item returned by find_first_sub_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8044081e5a4f8005a6193a80139d278"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_sub_be_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_first_sub_uint32_t to get the next elements that still satisfy the search. The item returned by find_first_sub_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3103416b536c3a1ee9ca920d454bde88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_sub_be_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_first_sub_uint64_t to get the next elements that still satisfy the search. The item returned by find_first_sub_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae536c6be7940d4b569a7364a5b2d1fef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_sub_be_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_first_sub_uint8_t to get the next elements that still satisfy the search. The item returned by find_first_sub_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bee3e41d002cab5a3df486a561ba218"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_sub_le_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_first_sub_uint16_t to get the next elements that still satisfy the search. The item returned by find_first_sub_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9269a4759ec8a740134b9570ed80bb25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_sub_le_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_first_sub_uint32_t to get the next elements that still satisfy the search. The item returned by find_first_sub_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2d658799c81c9247b0519413451f96f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_sub_le_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_first_sub_uint64_t to get the next elements that still satisfy the search. The item returned by find_first_sub_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cb83c715d926cd5b8828f3687e6d247"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_next_sub_le_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the next occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_first_sub_uint8_t to get the next elements that still satisfy the search. The item returned by find_first_sub_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the next position. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to the element (up to but not including) where to end the search (max value = nrows). </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adf9d6d08137f75dcfb5ec38ceba39327"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_be_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_last_uint16_t to get the previous elements that still satisfy the search. The item returned by find_last_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa44792bd1a7dfaa45773e7e49c2f059f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_be_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_last_uint32_t to get the previous elements that still satisfy the search. The item returned by find_last_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3967b3c5755b574df145f37cc360cee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_be_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_last_uint64_t to get the previous elements that still satisfy the search. The item returned by find_last_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff94d1aef0a66ce07bab6bf0c0ddfaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_be_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_last_uint8_t to get the previous elements that still satisfy the search. The item returned by find_last_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a921636d8260e1802233cb472294967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_le_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_last_uint16_t to get the previous elements that still satisfy the search. The item returned by find_last_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d50b9a44329e390b9707a79eaee7515"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_le_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_last_uint32_t to get the previous elements that still satisfy the search. The item returned by find_last_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f1c5f32b1638258784709ab70ce0660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_le_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_last_uint64_t to get the previous elements that still satisfy the search. The item returned by find_last_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a369942143f492fcfdb5d4cb8d09636af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_le_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_last_uint8_t to get the previous elements that still satisfy the search. The item returned by find_last_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9ec041ddd05ee0d729060cffbd4e0fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_sub_be_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_last_sub_uint16_t to get the previous elements that still satisfy the search. The item returned by find_last_sub_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a876e42d68a25cdeb15c006f552fcd765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_sub_be_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_last_sub_uint32_t to get the previous elements that still satisfy the search. The item returned by find_last_sub_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aea38c80485efd38b5a822209e051bcde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_sub_be_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_last_sub_uint64_t to get the previous elements that still satisfy the search. The item returned by find_last_sub_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7efa9aaa2547b44c075a27a9cb3f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_sub_be_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "be" format and sorted in ascending order. This function can be used after find_last_sub_uint8_t to get the previous elements that still satisfy the search. The item returned by find_last_sub_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad141127aec007f7828525422bdc65031"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_sub_le_uint16_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_last_sub_uint16_t to get the previous elements that still satisfy the search. The item returned by find_last_sub_uint16_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint16_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4317b5cffeea5a9ad8f9c7a70f7d0450"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_sub_le_uint32_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_last_sub_uint32_t to get the previous elements that still satisfy the search. The item returned by find_last_sub_uint32_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint32_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af24b6e68681756a0f468c32c8b5417f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_sub_le_uint64_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_last_sub_uint64_t to get the previous elements that still satisfy the search. The item returned by find_last_sub_uint64_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint64_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4204a4e9ba9f5006ab5db8657892959"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool has_prev_sub_le_uint8_t </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>blkpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the previous occurrence of an unsigned integer on a memory mapped binary file containing adjacent blocks of sorted binary data still matches the search value. The values in the file must be encoded in "le" format and sorted in ascending order. This function can be used after find_last_sub_uint8_t to get the previous elements that still satisfy the search. The item returned by find_last_sub_uint8_t should be set as the "pos" parameter in this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Memory mapped file address. </td></tr>
    <tr><td class="paramname">blklen</td><td>Length of the binary block in bytes. </td></tr>
    <tr><td class="paramname">blkpos</td><td>Indicates the position of the number to search inside a binary block. </td></tr>
    <tr><td class="paramname">bitstart</td><td>First bit position to consider (usually 0). </td></tr>
    <tr><td class="paramname">bitend</td><td>Last bit position to consider (usually the last bit, e.g. 7 for uint8_t, 15 for uint16_t, etc). </td></tr>
    <tr><td class="paramname">first</td><td>First element of the range to search (min value = 0). </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the current item position. This will be updated to point to the previous position. </td></tr>
    <tr><td class="paramname">search</td><td>Unsigned number to search (type uint8_t ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the next item is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2602c6d1d5e5cafbf14e61af75591ebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mmap_binfile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmmfile__t.html">mmfile_t</a> *&#160;</td>
          <td class="paramname"><em>mf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Memory map the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Path to the file to map. </td></tr>
    <tr><td class="paramname">mf</td><td>Structure containing the memory mapped file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory-mapped file descriptors. </dd></dl>

</div>
</div>
<a class="anchor" id="a9aa56179105cfc9bbdeac924bad26375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int munmap_binfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmfile__t.html">mmfile_t</a>&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unmap and close the memory-mapped file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>Descriptor of memory-mapped file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, munmap() returns 0, on failure -1, and errno is set (probably to EINVAL). </dd></dl>

</div>
</div>
<a class="anchor" id="a894480911a2f9c57026388b3893c64db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void parse_col_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmfile__t.html">mmfile_t</a> *&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a107bc0758ebb05df2a8013ada2629698"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void parse_info_arrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmfile__t.html">mmfile_t</a> *&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a052ad12bb8be4ecd923d01d4963f6129"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void parse_info_binsrc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmfile__t.html">mmfile_t</a> *&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a16247e7f04dd040d67acfa6e12582e9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void parse_info_feather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmfile__t.html">mmfile_t</a> *&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_95f36bb7017c611e74b72485a3bf1179.html">variantkey</a></li><li class="navelem"><a class="el" href="binsearch_8h.html">binsearch.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
